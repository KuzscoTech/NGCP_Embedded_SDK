#include "arm0_utilities.h"
/**
 * @brief 
 * 
 * @param InstancePtr 
 * @return int 
 */

int arm0_initializeServoPwm(servoMotor *InstancePtr)
{
	int Status;
	Status = ugvServo_intialize(servoMotor->servoPwm, SERVO_DRIVER_BASEADDR);
	return Status;
}

int arm0_initializeServoXADC(servoMotor *InstancePtr)
{
	int Status;
	XSysMon_Config *adcConfigPtr;
	//
	adcConfigPtr = XSysMon_LookupConfig(SERVO_XADC_DEVICE_ID);
	if(adcConfigPtr == NULL) {
		return XST_FAILURE;
	}

	Status = XSysMon_CfgInitialize(InstancePtr->servoAdc, adcConfigPtr, adcConfigPtr->BaseAddress);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

void arm0_configPID(servoMotor *InstancePtr)
{
	InstancePtr->servoPid.Kp = SERVO_PID_KP;
	InstancePtr->servoPid = { SERVO_PID_KP,
                              SERVO_PID_KI,
                              SERVO_PID_KD,
                              SERVO_PID_TAU,
                              SERVO_PID_LIM_MIN,
                              SERVO_PID_LIM_MAX,
                              SERVO_PID_LIM_MIN_INT,
                              SERVO_PID_LIM_MAX_INT,
                              SERVO_PID_SAMPLE_TIME };
}

int arm0_initializeDriveMotorPwm(ugv_pwm *InstancePtr)
{
    int Status;
    //
    Status = ugvPwm_Initialize(InstancePtr, DRIVEMOTOR_PWM_BASEADDR);
    if(Status != XST_SUCCESS) {
        printf("Drive Motor PWM initialization failed...\r\n");
        return XST_FAILURE;
    }

    ugvPwm_setPeriod   (InstancePtr, (u16) DRIVEMOTOR_PWM_PERIOD);
    ugvPwm_setMinPeriod(InstancePtr, (u16) DRIVEMOTOR_PWM_MIN);
    ugvPwm_setScaling  (InstancePtr, (u8)  DRIVEMOTOR_PWM_SCALE);
    ugvPwm_setIBT2Mode (InstancePtr);
    ugvPwm_Enable      (InstancePtr, TRUE);

    return XST_SUCCESS;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @param motorId 
 * @return int 
 */
int arm0_initializeMicroMetalPwm(ugv_pwm *InstancePtr, u8 motorId)
{
    int Status;
    //
    if(motorId == 0)
    {
        Status = ugvPwm_Initialize(InstancePtr, MGM0_PWM_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Drive Motor PWM initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvPwm_setPeriod   (InstancePtr, (u16) MGM0_PWM_PERIOD);
        ugvPwm_setMinPeriod(InstancePtr, (u16) MGM0_PWM_MIN);
        ugvPwm_setScaling  (InstancePtr, (u8)  MGM0_PWM_SCALE);
        ugvPwm_setL298Mode (InstancePtr);
        ugvPwm_Enable      (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else if(motorId == 1)
    {
        Status = ugvPwm_Initialize(InstancePtr, MGM1_PWM_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Drive Motor PWM initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvPwm_setPeriod   (InstancePtr, (u16) MGM1_PWM_PERIOD);
        ugvPwm_setMinPeriod(InstancePtr, (u16) MGM1_PWM_MIN);
        ugvPwm_setScaling  (InstancePtr, (u8)  MGM1_PWM_SCALE);
        ugvPwm_setL298Mode (InstancePtr);
        ugvPwm_Enable      (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else return XST_FAILURE;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @return int 
 */
int arm0_initializeDriveMotorQEI(ugv_qei *InstancePtr)
{
    int Status;
    Status = ugvQei_Initialize(InstancePtr, DRIVEMOTOR_QEI_BASEADDR);
    ugvQei_setMicroMetalMode(InstancePtr, FALSE);
    return Status;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @param qeiId 
 * @return int 
 */
int arm0_initializeMicroMetalQEI(ugv_qei *InstancePtr, u8 qeiId)
{
    int Status;
    if(qeiId == 0) 
    {   
        Status = ugvQei_Initialize(InstancePtr, MGM0_QEI_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Micrometal Encoder initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvQei_setMicroMetalRatio      (InstancePtr, MGM0_GEAR_RATIO);
        ugvQei_setMicroMetalResolution (InstancePtr, MGM0_RESOLUTION);
        ugvQei_setMicroMetalMode       (InstancePtr, TRUE);
        ugvPwm_Enable                  (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else if(qeiId == 1) 
    {
        Status = ugvQei_Initialize(InstancePtr, MGM1_QEI_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Micrometal Encoder initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvQei_setMicroMetalRatio      (InstancePtr, MGM1_GEAR_RATIO);
        ugvQei_setMicroMetalResolution (InstancePtr, MGM1_RESOLUTION);
        ugvQei_setMicroMetalMode       (InstancePtr, TRUE);
        ugvPwm_Enable                  (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else return XST_FAILURE;
}

/**
 * @brief 
 * 
 * @param driveMotor_setPoint 
 * @param driveMotor_rpm 
 * @param driveMotor_pid_setPoint 
 * @param driveMotorQeiInstance 
 * @param driveMotorPwmInstance 
 * @param driveMotorPIDInstance 
 */
void arm0_calculateDriveMotorPid(float *driveMotor_setPoint, driveMotor *driveMotor, ugv_qei *driveMotorQeiInstance, ugv_pwm *driveMotorPwmInstance, PIDController *driveMotorPIDInstance){

	if(driveMotor_setPoint < 0) {
		driveMotor->setDir = MOTOR_REVERSE;
	}
	else {
		driveMotor->setDir = MOTOR_FORWARD;
	}

	// get rpm
	driveMotor->currentRpm = (float) ugvQei_getRpm(driveMotorQeiInstance);
	driveMotor->currentDir = ugvQei_getDirection(driveMotorQeiInstance);

	// If motor going opposite way, set PID rpm measurement to 0
	if(driveMotor->setDir == MOTOR_REVERSE) {
		driveMotor->pid_setPoint = -*driveMotor_setPoint;
		ugvPwm_setDir(driveMotorPwmInstance, MOTOR_REVERSE);
		if(driveMotor->currentDir == MOTOR_FORWARD && driveMotor->currentRpm > 2) {
			driveMotor->rpm = 0;
		}
		else {
			driveMotor->rpm = driveMotor->currentRpm;
		}
	}
	else {
		driveMotor->pid_setPoint = *driveMotor_setPoint;
		ugvPwm_setDir(driveMotorPwmInstance, MOTOR_FORWARD);
		if(driveMotor->currentDir == MOTOR_REVERSE && driveMotor->currentRpm > 2) {
			driveMotor->rpm = 0;
		}
		else {
			driveMotor->rpm = driveMotor->currentRpm;
		}
	}

	calculatePid (driveMotorPIDInstance, driveMotor->pid_setPoint, driveMotor->rpm);
	ugvPwm_setSpeed(driveMotorPwmInstance, (u8) driveMotorPIDInstance->out);
}

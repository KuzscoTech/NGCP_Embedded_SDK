// https://www.mathworks.com/help/ident/ref/iddata.html


#include <stdio.h>
#include "xil_printf.h"
#include "sleep.h"
#include "xtime_l.h"
#include "driveMotor_utilities.h"

#define DBG_DUTY      1
#define DBG_SLAVEREGS 0
#define TEST_INC      1
#define DBG_SYS_ID    0


#define PWM_BASEADDR     XPAR_MOTORPWM_0_S00_AXI_BASEADDR
#define ENCODER_BASEADDR XPAR_MOTORENCODER_0_S00_AXI_BASEADDR

//#define PWM_MIN     0
//#define PWM_SCALE   39

int main()
{
	int Status;
	ugv_driveMotor driveMotorInst;
	ugv_qei        driveMotorQeiInst;
	ugv_pwm        driveMotorPwmInst;
	PIDController  driveMotorPidInst;

	XTime tStart, tEnd;
	float deltaT;
	int   timeFlag = 0;

	//
	Status = driveMotor_Initialize(&driveMotorInst, &driveMotorPwmInst,
			                       &driveMotorQeiInst, &driveMotorPidInst);
	if(Status != XST_SUCCESS) {
		printf("Stupid fucking drive motor initialization failed :(");
		return XST_FAILURE;
	}

	u32 cnt_actual;
	float driveMotor_setPoint = 100.0;
    while(1)
    {
    	driveMotor_setPidOutput(&driveMotorInst, &driveMotor_setPoint);

    	xil_printf("--------------------------------------------------\r\n");
    	xil_printf("Current RPM: %d\r\n", driveMotorInst.currentRpm);
    	if(driveMotorInst.currentDir == DRIVEMOTOR_REVERSE){
    		xil_printf("Current Dir: REVERSE\r\n");
    	}
    	else {
    		xil_printf("Current Dir: FORWARD\r\n");
    	}

    	cnt_actual = MOTORPWM_mReadReg(driveMotorInst.pwm->RegBaseAddress, 12);

        if(DBG_DUTY) {
            xil_printf("Counter Value  : %d\r\n", cnt_actual);
        }
    	xil_printf("Expected duty  : %d\r\n", driveMotorInst.pwm->speedSelect);
    	xil_printf("Actual duty    : %d\r\n", (cnt_actual-DRIVEMOTOR_PWM_MIN)/DRIVEMOTOR_PWM_SCALE);

    	if(DBG_SYS_ID)
    	{
    		if(!timeFlag) {
    			XTime_GetTime(&tStart);
    			timeFlag = 1;
    		}
    		else {
    			XTime_GetTime(&tEnd);
    			deltaT = 1.0 * (tEnd-tStart) / COUNTS_PER_SECOND;
    			XTime_GetTime(&tStart);
    			printf("%d %d %t\r\n", RPM, (u32) duty, deltaT);
    		}
    	}


    	if(DBG_PWM_SLAVEREGS) {
    		u32 reg_read = MOTORPWM_mReadReg(driveMotorInst.pwm->RegBaseAddress, 0);
    		xil_printf("PWM slv_reg0       : %x\r\n", reg_read);
    		reg_read = MOTORPWM_mReadReg(driveMotorInst.pwm->RegBaseAddress, 4);
    		xil_printf("PWM slv_reg1       : %x\r\n", reg_read);
    		reg_read = MOTORPWM_mReadReg(driveMotorInst.pwm->RegBaseAddress, 8);
    		xil_printf("PWM slv_reg2       : %x\r\n", reg_read);
    		reg_read = MOTORPWM_mReadReg(driveMotorInst.pwm->RegBaseAddress, 12);
    		xil_printf("PWM slv_reg3       : %x\r\n", reg_read);
    	}
    	if(DBG_QEI_SLAVEREGS){
    		reg_read = MOTORENCODER_mReadReg(driveMotorInst.qei->RegBaseAddress, 0);
    		xil_printf("QEI slv_reg0       : %x\r\n", reg_read);
    		reg_read = MOTORENCODER_mReadReg(driveMotorInst.qei->RegBaseAddress, 4);
    		xil_printf("QEI slv_reg1       : %x\r\n", reg_read);
    		reg_read = MOTORENCODER_mReadReg(driveMotorInst.qei->RegBaseAddress, 8);
    		xil_printf("QEI slv_reg2       : %x\r\n", reg_read);
    		reg_read = MOTORENCODER_mReadReg(driveMotorInst.qei->RegBaseAddress, 12);
    		xil_printf("QEI slv_reg3       : %x\r\n", reg_read);
    	}

    }

//////////////////
    return 0;
}

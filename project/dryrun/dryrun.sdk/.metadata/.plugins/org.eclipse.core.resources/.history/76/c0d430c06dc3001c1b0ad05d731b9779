#include "driveMotor_utilities.h"


/* Function to initialize a ugv_driveMotor instance. */
int driveMotor_Initialize(ugv_driveMotor *InstancePtr)
{
	return XST_SUCCESS;
}

/* Function to initialize the PWM of a ugv_driveMotor instance. */
int driveMotor_pwmInitialize(ugv_driveMotor *InstancePtr, ugv_pwm *PwmInstancePtr)
{
	int Status;

	// Set the ugv_driveMotor pwm pointer
	InstancePtr->pwm = PwmInstancePtr;

	// initialize the pwm
	Status = ugvPwm_Initialize(InstancePtr->pwm, DRIVEMOTOR_PWM_BASEADDR);
	if(Status != XST_SUCCESS) {
	    return XST_FAILURE;
	}

	// set parameters
	ugvPwm_setPeriod   (InstancePtr->pwm, (u16) DRIVEMOTOR_PWM_PERIOD);
	ugvPwm_setMinPeriod(InstancePtr->pwm, (u16) DRIVEMOTOR_PWM_MIN);
	ugvPwm_setScaling  (InstancePtr->pwm, (u8)  DRIVEMOTOR_PWM_SCALE);
	ugvPwm_setIBT2Mode (InstancePtr->pwm);
	ugvPwm_Enable      (InstancePtr->pwm, TRUE);

	return XST_SUCCESS;
}

/* Function to initialize the QEI of a ugv_driveMotor instance */
int driveMotor_qeiInitialize(ugv_driveMotor *InstancePtr, ugv_qei *QeiInstancePtr)
{
	int Status;

	// Set the ugv_driveMotor qei pointer
	InstancePtr->qei = QeiInstancePtr;

	// Initialize the qei
	Status = ugvQei_Initialize(InstancePtr, DRIVEMOTOR_QEI_BASEADDR);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Configure qei for IBT2
	ugvQei_setMicroMetalMode(InstancePtr, FALSE);

	return XST_SUCCESS;
}

/* Function to update the PID output of a ugv_driveMotor instance. */
void driveMotor_updatePid(ugv_driveMotor *InstancePtr, float *driveMotor_setPoint)
{
	// get rpm
	InstancePtr->currentRpm = (float) ugvQei_getRpm (InstancePtr->qei);
	InstancePtr->currentDir = ugvQei_getDirection   (InstancePtr->qei);

	// If motor going opposite way, set PID measurement to 0
	if(InstancePtr->pwm->setDirection == MOTOR_REVERSE) {
		// get abs of setpoint
		InstancePtr->pid_setPoint = -*driveMotor_setPoint;

		// set direction
		ugvPwm_setDir(InstancePtr->pwm, MOTOR_REVERSE);
		InstancePtr->pwm->setDirection = MOTOR_REVERSE;

		// adjust pid measurement
		if(InstancePtr->currentDir == MOTOR_FORWARD && InstancePtr->currentRpm > 2) {
			InstancePtr->pid_measurement = 0;
		}
		else {
			InstancePtr->pid_measurement = InstancePtr->currentRpm;
		}
	}
	else {
		// get abs of setpoint
		InstancePtr->pid_setPoint = *driveMotor_setPoint;

		// set direction
		ugvPwm_setDir(InstancePtr->pwm, MOTOR_FORWARD);
		InstancePtr->pwm->setDirection = MOTOR_FORWARD;

		// adjust pid measurement
		if(InstancePtr->currentDir == MOTOR_REVERSE && InstancePtr->currentRpm > 2) {
			InstancePtr->pid_measurement = 0;
		}
		else {
			InstancePtr->pid_measurement = InstancePtr->currentRpm;
		}
	}

	// calculate pid output and set pwm duty cycle
	calculatePid(InstancePtr->pid, InstancePtr->pid_setPoint, InstancePtr->pid_measurement);
}



















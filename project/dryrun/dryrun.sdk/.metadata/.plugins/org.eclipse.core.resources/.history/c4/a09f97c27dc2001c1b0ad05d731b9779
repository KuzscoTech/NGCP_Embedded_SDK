#include "arm0_utilities.h"

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @return int 
 */
int arm0_initializeDriveMotorPwm(ugv_pwm *InstancePtr)
{
    int Status;
    //
    Status = ugvPwm_Initialize(InstancePtr, DRIVEMOTOR_PWM_BASEADDR);
    if(Status != XST_SUCCESS) {
        printf("Drive Motor PWM initialization failed...\r\n");
        return XST_FAILURE;
    }

    ugvPwm_setPeriod   (InstancePtr, (u16) DRIVEMOTOR_PWM_PERIOD);
    ugvPwm_setMinPeriod(InstancePtr, (u16) DRIVEMOTOR_PWM_MIN);
    ugvPwm_setScaling  (InstancePtr, (u8)  DRIVEMOTOR_PWM_SCALE);
    ugvPwm_setIBT2Mode (InstancePtr);
    ugvPwm_Enable      (InstancePtr, TRUE);

    return XST_SUCCESS;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @param motorId 
 * @return int 
 */
int arm0_initializeMicroMetalPwm(ugv_pwm *InstancePtr, u8 motorId)
{
    int Status;
    //
    if(motorId == 0)
    {
        Status = ugvPwm_Initialize(InstancePtr, MGM0_PWM_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Drive Motor PWM initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvPwm_setPeriod   (InstancePtr, (u16) MGM0_PWM_PERIOD);
        ugvPwm_setMinPeriod(InstancePtr, (u16) MGM0_PWM_MIN);
        ugvPwm_setScaling  (InstancePtr, (u8)  MGM0_PWM_SCALE);
        ugvPwm_setL298Mode (InstancePtr);
        ugvPwm_Enable      (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else if(motorId == 1)
    {
        Status = ugvPwm_Initialize(InstancePtr, MGM1_PWM_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Drive Motor PWM initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvPwm_setPeriod   (InstancePtr, (u16) MGM1_PWM_PERIOD);
        ugvPwm_setMinPeriod(InstancePtr, (u16) MGM1_PWM_MIN);
        ugvPwm_setScaling  (InstancePtr, (u8)  MGM1_PWM_SCALE);
        ugvPwm_setL298Mode (InstancePtr);
        ugvPwm_Enable      (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else return XST_FAILURE;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @return int 
 */
int arm0_initializeDriveMotorQEI(ugv_qei *InstancePtr)
{
    int Status;
    Status = ugvQei_Initialize(InstancePtr, DRIVEMOTOR_QEI_BASEADDR);
    ugvQei_setMicroMetalMode(InstancePtr, FALSE);
    return Status;
}

/**
 * @brief 
 * 
 * @param InstancePtr 
 * @param qeiId 
 * @return int 
 */
int arm0_initializeMicroMetalQEI(ugv_qei *InstancePtr, u8 qeiId)
{
    int Status;
    if(qeiId == 0) 
    {   
        Status = ugvQei_Initialize(InstancePtr, MGM0_QEI_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Micrometal Encoder initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvQei_setMicroMetalRatio      (InstancePtr, MGM0_GEAR_RATIO);
        ugvQei_setMicroMetalResolution (InstancePtr, MGM0_RESOLUTION);
        ugvQei_setMicroMetalMode       (InstancePtr, TRUE);
        ugvPwm_Enable                  (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else if(qeiId == 1) 
    {
        Status = ugvQei_Initialize(InstancePtr, MGM1_QEI_BASEADDR);
        if(Status != XST_SUCCESS) {
            printf("Micrometal Encoder initialization failed...\r\n");
            return XST_FAILURE;
        }
        ugvQei_setMicroMetalRatio      (InstancePtr, MGM1_GEAR_RATIO);
        ugvQei_setMicroMetalResolution (InstancePtr, MGM1_RESOLUTION);
        ugvQei_setMicroMetalMode       (InstancePtr, TRUE);
        ugvPwm_Enable                  (InstancePtr, TRUE);
        return XST_SUCCESS;
    }
    else return XST_FAILURE;
}

/**
 * @brief 
 * 
 * @param driveMotor_setPoint 
 * @param driveMotor_rpm 
 * @param driveMotor_pid_setPoint 
 * @param driveMotorQeiInstance 
 * @param driveMotorPwmInstance 
 * @param driveMotorPIDInstance 
 */
void arm0_utilities_CalculatePid(float *driveMotor_setPoint, float *driveMotor_rpm, float *driveMotor_pid_setPoint, ugv_qei *driveMotorQeiInstance, ugv_pwm *driveMotorPwmInstance, PIDController *driveMotorPIDInstance){        
        if(driveMotor_setPoint < 0) {
        	driveMotor_setDir = MOTOR_REVERSE;
        }
        else {
        	driveMotor_setDir = MOTOR_FORWARD;
        }

        // get rpm
        driveMotor_currentRpm = (float) ugvQei_getRpm(&driveMotorQeiInstance);
        driveMotor_currentDir = ugvQei_getDirection(&driveMotorQeiInstance);

        // If motor going opposite way, set PID rpm measurement to 0
        if(driveMotor_setDir == MOTOR_REVERSE) {
        	driveMotor_pid_setPoint = -driveMotor_setPoint;
        	ugvPwm_setDir(&driveMotorPwmInstance, MOTOR_REVERSE);
        	if(driveMotor_currentDir == MOTOR_FORWARD && driveMotor_currentRpm > 2) {
        		driveMotor_rpm = 0;
        	}
        	else {
        		driveMotor_rpm = driveMotor_currentRpm;
        	}
        }
        else {
        	driveMotor_pid_setPoint = driveMotor_setPoint;
        	ugvPwm_setDir(&driveMotorPwmInstance, MOTOR_FORWARD);
        	if(driveMotor_currentDir == MOTOR_REVERSE && driveMotor_currentRpm > 2) {
        		driveMotor_rpm = 0;
        	}
        	else {
        		driveMotor_rpm = driveMotor_currentRpm;
        	}
        }
        
        calculatePid (&driveMotorPIDInstance, driveMotor_pid_setPoint, driveMotor_rpm);
        ugvPwm_setSpeed(&driveMotorPwmInstance, (u8) driveMotorPIDInstance.out);
}